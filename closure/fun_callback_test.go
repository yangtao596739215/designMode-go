package closure

import (
	"context"
	"testing"
)

/*
【互相依赖的东西，可以以结构互相持有的方式实现，或者方法动态传参，或者队列生产消费等】

如果一个结构体的方法里面接受了一个函数作为参数，其实效果和给这个结构体增加了一个成员变量差不多，当然，成员变量也可以是函数

函数的代表一段逻辑操作，如果一个函数的参数里面还是函数，代表这段逻辑里面有一段可变的子逻辑

1. 便于分层设计：函数指针是引用，是间接层，或曰隔离层。它输出到上层，给上层用户用。函数实体是实现，在下层，给开发者用，实现者（软件工程师）关注。
这就是简单的分层的概念了。上层用户想让一个函数所做的东西会变化时，我们只需要改变底层实现，并用函数指针指向新的实现就行了。
再精炼一下分层：分层的核心是对接口进行设计和实现。函数指针的作用就是提供不同实现的统一接口。
2. 利于系统抽象：只有存在多个类似的实体需要模拟、操作或控制时（这种情况很多）才需要抽象。多个类似的实体就是对象，抽象的结果就是类。在C里边，可以用函数指针数组完成这种抽象。
如， fopen 就是一个例子。他可以打开文件。C里面将磁盘文件、串口、USB等诸多设备抽象为文件。
3. 降低耦合度以及使接口与实现分开

【分层是最重要的思想，层级是可以无限划分的，比如，代码通常分为逻辑层，handler层，rpc层，但是，逻辑里面也可以有自己的分层】
【比如，kafka的消费，本身也可以分层，连接层获取二进制，hook层进行条件判断决定是否要转发，进行类型转换和打点的层，实际进行用户逻辑处理的层】
【好的系统，一定是层次清晰的，牛逼的系统，在层次清晰的基础上，能处理好各个层次之间的依赖关系】
【层次也是递进的，大的层级下面，也有小的子层，当一个逻辑复杂起来，就需要进行分层，以保障可扩展性】
【落实到具体系统的代码层面，只有真正里面各个系统中各个模块和子模块的分层逻辑，才能理解这个系统，理解了各个层级直接的依赖实现，就算熟悉这个系统了】
*/

/*
回调函数的定义：如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，就说这是回调函数。

回调函数的作用：解耦

使用回调函数，和普通函数调用区别：
1）在主入口程序中，把回调函数像参数一样传入库函数。这样一来，只要我们改变传进库函数的参数，就可以实现不同的功能，且不需要修改库函数的实现，变的很灵活，这就是解耦。
2）主函数和回调函数是在同一层的，而库函数在另外一层。如果库函数对我们不可见，我们修改不了库函数的实现，也就是说不能通过修改库函数让库函数调用普通函数那样实现，那我们就只能通过传入不同的回调函数了，这也就是在日常工作中常见的情况。
回调函数其实就是函数指针的一种用法：A "callback" is any function that is called by another function which takes the first function as a parameter。
注：使用回调函数会有间接调用，因此，会有一些额外的传参与访存开销，对于MCU代码中对时间要求较高的代码要慎用。

回调函数如何使用：使用其实也是不得已而为之，是一种解决问题的策略

回调函数的使用是对函数指针的应用，函数指针的概念本身很简单，但是把函数指针应用于回调函数就体现了一种解决问题的策略，一种设计系统的思想。

回调函数的缺点：
1）回调函数固然能解决一部分系统架构问题但是绝不能再系统内到处都是，如果你发现你的系统内到处都是回调函数，那么你一定要重构你的系统。

2）回调函数本身是一种破坏系统结构的设计思路，回调函数会绝对的变化系统的运行轨迹，执行顺序，调用顺序。回调函数的出现会让读到你的代码的人非常的懵头转向。

回调函数是一种不得以而为之的设计策略比如：
在一个下载系统中有一个文件下载模块和一个下载文件当前进度显示模块，系统要求实时的显示文件的下载进度，想想很简单在面向对象的世界里无非是实现两个类而已。
但是问题恰恰出在这里，显示模块如何驱动下载进度条？显示模块不知道也不应该知道下载模块所知道的文件下载进度（面向对象设计的封装性，模块间要解耦，模块内要内聚），
文件下载进度是只有下载模块才知道的事情，解决方案很简单给下载模块传递一个函数指针作为回调函数驱动显示模块的显示进度。

在面向对象的世界中这样的例子还真不少，造成这样的问题的根源，是面向对象的程序设计思想，设计模式中要求的模块独立性，高内聚低耦合等特性。

我们需要模块间的协作，同时我们又厌恶的摒弃模块间你中有我我中有你的暧昧关系那如何生成系统呢？是函数指针（不一定一定是函数指针）也就是使用回调的方式。
如果一个对象关心另一个对象的状态变化那么给状态的变化注册回调函数让它通知你这类状态的改变，这样在封装了模块变化的同时实现了模块间的协作关系另辟独径的给对象解耦。
*/

//好的库函数，或者框架，会提供一些回调点给用户，实现用户自定义的逻辑
func Lib(ctx context.Context, input int, fn func(i int) int) {
	fn(input)
}

//本质上还是多态，如果多态只有一种实现，那就是依赖关系的另一种体现【互相依赖的东西，可以以结构互相持有，或者方法动态传参，或者队列生产消费实现】
func TestLib(t *testing.T) {
	Lib(context.Background(), 2, func(i int) int {
		return i + 23
	})
}
